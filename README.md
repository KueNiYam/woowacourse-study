# 소개
 - 우아한테크코스에서 학습한 내용을 개인적인 공부 목적으로 정리한 저장소입니다.
 > 예시 코드는 src 디렉토리에서 확인할 수 있습니다.

------
# 온보딩
## main method vs JUnit
### main method 의 용도
 - 프로그램을 시작
 - 구현한 프로그램을 테스트
 > 이 과정은 main method 를 테스트 용도로 사용하는 경우에 대해 다루고 있다.

### main method 의 문제점
 - Production code 와 Test code 가 클래스 하나에 존재한다.
 > 클래스 크기가 커짐 -> 복잡도 증가
 - Test Code 가 실서비스에 같이 배포된다.
 - **main method 에서 여러 개의 기능을 테스트한다.**
 - method 이름을 통해 어떤 부분을 테스트하는지에 대한 의도를 들어내기 힘들다.
 - 테스트 결과를 사람이 수동으로 확인한다.
 
### JUnit
 - main method 를 활용해 테스트할 때 발생하는 문제점을 해결하기 위해 등장한 도구가 JUnit 이다.
 - 애노테이션(Annotation)을 활용해 테스트를 구현한다.
    - @Test
    - @BeforeEach, @Aftereach
    - @BeforeAll, @AfterAll
 > JUnit 5.x 기준    
 - Assert 클래스의 static assert method 를 활용해 테스트 결과를 검증한다.
 
### Assertion
 - assertj: 메소드 체이닝을 통해 좀 더 깔끔하고 읽기 쉬운 assert 코드를 구현할 수 있다.
 
## 학습테스트와 단위테스트
### 학습테스트란?
 - 기능구현을 위한 테스트라기 보다는 새로운 API, 라이브러리, 프레임워크가 어떻게 동작하는지를 검증하기 위한 테스트

### 학습테스트 장점
 - 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.
 - 학습 테스트 코드를 개발 중에 참고할 수 있다.
 - 프레임워크나 제품을 업그레이드할 때 호환성 검증을 보여준다.
 - 테스트 코드 작성에 좋은 훈련이 된다.
 - 새로운 기술을 검증하는 과정이 즐거워진다.
 
### 단위 테스트
단위 테스트는 프로덕션 코드를 구현한 후 JUnit 과 같은 도구를 활용해 작은 단위를 테스트하는 것을 의미한다.
단위 테스트와 TDD 는 다르다.

------
내가 구현하는 메소드(함수) 중
Input 과 Output 이 명확한 클래스 메소드(보통 Util 성격의 메소드)
에 대한 단위 테스트 연습

------
알고리즘을 학습한다면 알고리즘 구현에 대한 검증을 단위 테스트로 한다.
알고리즘은 Input, Output 이 명확하기 때문에 연습하기 좋다.

## 자바 문자열
### 학습 목표
 - 문자(char, Character)와 문자열(String)
 - StringBuilder 와 StringBuffer
 
### 문자와 문자열
 - 문자열(String)은 자바 프로그램이 실행되는 동안 가장 많이 생성되는 객체이다.
 - 문자열은 객체이지만 각각의 문자의 나열로 구성된다.
 - char capitalA = 'A'; // 문자
 - String a = "abc"; // 문자열 == 문자의 배열
 - String b = new String("abc"); // **이따구로 구현하지 마라.**
 
### StringBuilder API
String + String vs StringBuilder
 - String 은 불변(Immutable)하기 때문에 String 과 String 을 더하면 String 객체를 생성한다. 따라서 String 과 String 을 더하는 시점에 메모리 할당과 메모리 해제가 계속해서 발생한다.
 - StringBuilder 는 String 과 다르게 기존 데이터에 새로운 데이터를 더하는 방식을 취하기 때문에 속도가 더 빠르다.
 - 따라서 긴 문자열을 더하는 상황이 발생할 경우 StringBuilder 를 활용해 구현한다.
 ------
 Immutable
  - Immutable(불변)이란 객체를 생성한 후 상태를 변경할 수 없는 것을 의미한다.
  - String 객체는 문자열의 상태 값을 변경할 수 없기 때문에 Immutable 객체라 한다.
  
## 자바 List, Generic
### List
#### java.util.List Interface
 - 자바는 배열과 같은 데이터를 효과적으로 처리하기 위해 배열 대신 List 를 제공한다.
 - List 는 ArrayList, LinkedList 두 가지 종류가 있다. 일반적으로 ArrayList 를 가장 많이 사용한다.
 - List 는 배열에서 지원하지 않는 많은 기능을 제공한다.
 - 지금까지 배열을 사용했다면 배열대신 List 를 사용한다.
 
#### ArrayList vs LinkedList
 - ArrayList 와 LinkedList 사용 방법은 같다.
 - 다른 점은 데이터를 저장하는 방식이 다르다는 것 뿐이다.
 - ArrayList 데이터 저장 방식
 ------
 Index: 0 1 2 3 4 
 Value: 1 4 6 7 9
 ------
 - LinkedList 데이터 저장 방식
 ------
 1|· -> 4|· -> 6|· -> 7|· -> 9

 ------


 ### Generic
 - List 와 같이 다양한 종류의 데이터를 관리하는 경우 데이터 타입을 특정 데이터 타입으로 고정할 수 있다.
 
 ### Generic 장점
 - 특정 타입으로 고정함으로써 타입 안정성을 제공한다.
 - 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.
 
### Generic 을 사용하지 않을 경우
 - 다양한 종류의 객체의 타입을 추가할 수 있다. (특정 Type => Object)
 - 추가한 객체 타입을 사용하려면 다시 형변환을 해야 한다. (Object => 특정 Type)
 
### Generic 을 사용하는 경우
 - ArrayList<String> 와 같이 <>을 이용해 ArrayList 가 관리하는 타입을 지정한다.
 - 이와 같이 타입을 지정하면 해당 타입만 추가할 수 있다. 다른 타입을 저장하면 컴파일 에러가 발생한다.
**특별히 예외적인 상황이 아니라면 Generic 을 사용한다.**

## JavaDoc 읽기
 - 자바에서 제공하는 API 를 사용할 때 JavaDoc 문서를 참고해 사용법을 익힌다.

------

# 자동차 경주 - TDD
## 자바 Package 와 Import
### 패키지(Package)

- 관련된 클래스들을 모아서 한 번에 관리할 수 있도록 한다.
- 한 곳에서 수백 수천 개의 클래스를 찾는 수고를 덜어준다.
- 배포할 때 관련된 소스 코드들을 묶어서 배포하고 재사용할 수 있도록 한다.
- 각 프로젝트나 소프트웨어 간의 소스 코드 충돌을 방지한다.

------ 
패키지 구현

- 프로그램 구현 디렉토리 아래에 패키지 이름을 추가한다.
- 패키지에 클래스를 추가하는 경우 package 키워드를 활용해 클래스가 어느 패키지에 위치하는지 명시해야 한다.

------
패키지 Convention

- 패키지명은 일반적으로 회사 도메인명을 사용하는 것이 관례이다.
- 모든 패키지 이름은 소문자로 사용하는 것이 관례이다.
- 패키지 이름은 java 또는 javax 로 시작해서는 안 된다. 이 둘은 JDK 에서 독점적으로 사용하는 패키지 이름이다.

------
java.lang 패키지 Import

- 자바는 기본이 되는 클래스라 대부분의 클래스에서 자주 사용하는 클래스를 java.lang 에서 자동으로 import 한다.
- 대표적으로 String, Integer 와 같은 클래스는 import 없이 사용할 수 있다.
- System 도 클래스인데 import 를 하지 않아도 사용 가능한 이유는 java.lang.System 에 존재하기 때문에 자동으로 import 된 것이다.

## 클래스와 인스턴스

클래스 vs 인스턴스(객체)

- 클래스: 인스턴스를 생성하기 위한 틀(Template). 클래스 자체만으로는 상태가 없다.
- 인스턴스:(단수 의미로 객체): 클래스를 통해 실체화되어 생성된다. 인스턴스는 상태를 가지며, 메소드를 통해 인스턴스의 상태가 변경된다.

------
인스턴스 메소드, 필드

- 인스턴스 메소드: 인스턴스의 상태를 변경하거나 상태 정보를 반환할 때 사용하는 메소드
> 인스턴스를 생성한 후 메시지를 보낼(메소드를 호출)할 수 있다.
- 인스턴스 필드: 인스턴스의 상태 정보를 가지고 있는 변수, 상태 변수라고도 이야기한다.

------
클래스 메소드, 필드

- 클래스 메소드: 인스턴스의 상태와는 관련이 없다. 인스턴스를 생성하지 않은 상태에서도 호출이 가능하다. 클래스 메소드는 유틸리티 메소드라고 부른다.
> 클래스 메소드를 유틸리티 메소드라고 부르는 이유가 뭘까?
- 클래스 필드: 여러 인스턴스에서 공유하는 정보가 있는 경우 사용한다.

------
static

- static: 자바 언어 예약어로 클래스 메소드와 클래스 필드를 지정할 때 사용한다.

------
private 생성자 추가를 통한 리팩토링

- **메소드를 클래스 메소드로 만드는 것과 더불어 DateUtils 의 생성자를 private 으로 만드는 것이 좋다.**
- DateUtils 객체를 생성하도록 허용해도 상관없지만 클래스의 모든 메소드가 클래스 메소드일 경우에는 명시적으로 클래스를 생성할 수 없도록 하는 것이 DateUtils 을 사용하는 개발자 입장에서 더 명확하다.

```java
    public class DateUtils {
        private DateUtils() {}
    }
```

------
인스턴스 필드, 클래스 필드 유효 기간

- 인스턴스 변수의 유효 기간은 인스턴스가 생성되었다가 소멸되는 시점까지이다.
- 클래스 변수의 유효 기간은 애플리케이션을 실행하고 JVM 이 클래스를 Load 하는 시점부터 클래스가 Unload 하는 시점까지이다.

------
**JVM load**
- JVM 은 클래스가 필요한 시점에 동적으로 클래스 바이트 코드를 읽어 메모리에 할당한다.
- 이 과정을 load 한다고 한다.

**JVM unload**
- JVM 은 클래스를 더 이상 사용하지 않는 경우 메모리에서 클래스를 해체한다. 이 과정을 unload 라고 한다.

### 생성자
생성자(Constructor)
- 객체를 생성하기 위해 호출하는 메소드
- 객체와 이름이 동일
- return value 가 없다.
- 여러 개의 생성자를 제공하면 객체 생성시에 적절히 사용할 수 있다.
> Constructor overloading

------
기본(Default) 생성자
- 인수가 없는 생성자를 default 생성자라 한다.
    - 객체에서 생성자가 제공되지 않으면 JVM 이 default 생성자를 만들어 준다.
    - 이미 파라미터가 있는 다른 생성자가 있으면 JVM 은 생성자를 기본으로 생성하지 않는다.

## TDD, 리팩토링이란?
### TDD 란?
- TDD = TFD(Test First Development) + 리팩토링

------ 
- TDD 란 프로그래밍 의사결정과 피드백 사이의 간극을 의식하고 이를 제어하는 기술이다.
> 켄트백, Test Driven Development by Example 중
- TDD 의 아이러니 중 하나는 테스트 기술이 아니라는 점이다. TDD 는 분석 기술이며, 설계 기술이기도 하다.
> 켄트백, Test Driven Development by Example 중

### TDD 를 하는 이유
- 디버깅 시간을 줄여준다.
- 동작하는 문서 역할을 한다.
- 변화에 대한 두려움을 줄여준다.

### TDD 사이클
- 실패하는 테스트를 구현한다.
- 테스트가 성공하도록 프로덕션 코드를 구현한다.
- 프로덕션 코드와 테스트 코드를 리팩토링한다.

### TDD 원칙
- 원칙 1 - 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드(production code)를 작성하지 않는다.
- 원칙 2 - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 원칙 3 - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

### 나는 왜 TDD 에 집착하는가?
#### 1. 나는 사람이다.
요구사항 추가, 변경때문에 소스코드를 수정하고 불안감에 살고 싶지 않다.

------
사람답게 살고 싶다.
#### 2. 나는 평범하다.
한 번에 한 가지만 집중할 수 있다.

------
- Test fails => Test passes
    - 입력, 출력에 집중
    - 로직을 구현하는 것에 집중
    - 테스트를 통과하기 위해 어떠한 행위도 허용
- 심적으로 안정감을 얻을 수 있다.
- 리팩토링
    - 설계
    - 클린 코드
    
------
처음부터 완벽한 설계를 하는 것이 아니라 **점진적으로 설계**를 계선해 나갈 수 있다.

- 변화에 빠르게 대응할 수 있는 소스 코드와 연습
- 과도한 설계(Overengineering)에 따른 추가 비용을 해소

#### 3. 나는 프로그래밍을 좋아한다.
빠른 피드백을 통한 개발 효율
- 버그를 찾는 시점이 빨라짐
- 일정한 리듬으로 일함으로써 프로그래밍에 재미를 느낌
- 더 많은 삽질을 할 수 있음. 삽질은 더 많은 배움

### TDD, 리팩토링 적용 효과
서비스 안정성이 높아짐
- 버그 발생 가능성이 줄어든다.
- 코드 품질이 높아져 변화에 좀 더 빠르게 대응할 수 있다.

개발자들의 역량 강화
- 학습 효율이 높아져 개발자의 역량을 높일 수 있다.
- 개발자들의 만족도가 높아져 이직율이 낮아질 수 있다.

수동 테스트, 배포에 대한 부담을 줄이면서 핵심 비즈니스 로직 구현에 집중
> 지금 필요한 것은 새로운 접근 방식에 도전할 수 있는 용기****

### 프로덕션 코드 리뷰
code convection, format 맞추기
- 상수 값의 경우 static final, 변수 이름은 대문자
- 클래스 변수의 위치는?
> 클래스 변수, 인스턴스 변수, 생성자 순으로 위치한다.
- 공백 라인을 의미있게 사용하라.
> 문맥을 분리하는 부분에 사용한다.
- space 도 고려한다.
- code format 기능은 Eclipse, intellij 도구들의 formatting 기능을 활용할 것을 추천한다.

------
이름 짓기
- 자료구조나 특정 Type 에 종속된 이름을 피한다.

------
final 사용해 값 변경 막기
- 최근에 등장하는 언어들은 변수의 기본이 불변
- 자바는 final 을 활용해 값의 변경을 막는 것이 가능

------
객체를 객체스럽게 사용하도록 리팩토링해라
- Car 클래스를 추가한 후 name 과 position 을 상태 값으로 객체를 추가했다.
- 그런데 이 객체는 로직에 대한 구현은 하나도 없고, name 과 position 에 대한 setter 와 getter 메소드만을 가진다.
- 상태 값을 가지는 Car 가 좀 더 객체다운 역할을 하도록 리팩토링한다.

------
객체의 상태 접근을 제한한다.
- 객체 인스턴스 변수의 접근 제어자는 private 으로 구현한다.

단위 테스트하기 어려운 코드 단위 테스트하기
- 다음 코드는 Random 때문에 단위 테스트하기 힘들다. 단위 테스트가 가능하도록 리팩토링한다면 어떻게 리팩토링하는 것이 좋을까?
> 테스트 가능한 코드와 테스트하기 힘든 부분을 분리

------
인스턴스 변수의 수를 최소화한다.
- 인스턴스 변수의 수를 최소화할 수 있는 방법을 찾는다.
- 인스턴스 변수에 중복이 있는지를 확인하고 제거할 수 있는 방법을 찾는다.
- 다른 인스턴스 변수를 통해 생성할 수 있는 값을 굳이 인스턴스 변수로 구현하지 마라.

------
setter 메소드 사용을 자제한다.
- 인스턴스를 초기화한 후에 값을 변경할 수 있는 setter 메소드를 생성하지 않는다.
- 가능하면 생성자를 사용해 초기화한다.

------
상태 데이터를 get 하지 말고 메시지를 보내라.
- 객체의 데이터를 꺼내 로직을 구현하면 중복 코드가 발생한다.
- 객체에 메시지를 보내 상태 데이터를 가지는 객체가 일하도록 하라.

------
비즈니스 로직과 UI 로직의 분리
- 비즈니스 로직과 UI 로직을 분리해 UI 가 변경되더라도 핵심 비즈니스 로직을 재사용 가능하도록 한다.

------
비즈니스 로직과 UI 로직의 분리
- 비즈니스 로직과 UI 로직을 분리해 UI 가 변경되더라도 핵심 비즈니스 로직을 재사용 가능하도록 한다.

------
Collection 활용 로직 처리
- 다음 코드는 Car 목록에서 최종 우승자를 구하는 로직이다. 이 코드를 Collection 기능을 사용해 어떻게 리팩토링할 것인가?

### 테스트 코드 리뷰
어느 부분을 테스트할 것인가?
- 어느 정도의 테스트가 적정한가?
- 경계 값을 기준으로 테스트

------
Test Fixture 생성
- Fixture 란 테스트를 실행하기 위해 필요한 것으로 테스트를 실행하기 위해 준비해야할 것들을 의미한다.
- 테스트의 인스턴스 변수는 각 Test Case 에서 공통으로 필요한 Fixture 만 위치, 나머지는 각 Test Case 에 로컬 변수로 구현한다.

------
특정 상태를 만들기 위한 반복 코드
- 우승자 구하는 로직을 테스트하기 위해 Test Fixture 준비
- Test Fixture 를 위해 Car(String name, int position) 생성자를 추가한다면

### MVC
- 기본 패턴으로 MVC 패턴(Model View Controller) 구조를 유지하면서 구현하면 큰 틀에서의 분리가 가능함

------
도메인 로직 테스트에 집중
- 1차적으로는 도메인 로직을 테스트하는 것에 집중
- 테스트 가능한 부분과 어려운 부분을 분리
> Random 값 테스트는 테스트가 어려운 부분

# 로또 - OOP
## 자바 enum
enum 클래스
- 클래스를 상수처럼 사용할 수 있다.